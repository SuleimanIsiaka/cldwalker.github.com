---
layout: post
title: Lightning - Everything is Local
description: Introducing <a href="http://github.com/cldwalker/lightning">lightning</a>, a commandline framework that changes how you use paths in your filesystem. <a href="http://tagaholic.me/lightning/">Lightning</a> generates shell functions which wrap <b>any command</b> with the ability to autocomplete and interpret paths simply by their basenames. The era of carpal-typing long paths is <b>over</b>.
tags:
- gem:name=lightning
- post:topic=shell
- post:lang=ruby
- post:type=tutorial
related_tag: *:*=(lightning|shell)
---
{{page.description}}

h2. Overview

* "Install":#install
* "Intro":#intro
* "Lightning Bolts":#lightning_bolts
* "Everything is Local":#everything_is_local
* "Generators":#generators
* "Conclusion":#conclusion

h2(#install). "Install":#install

Lightning is a commandline library that works with "bash":http://www.gnu.org/software/bash/ or "zsh":http://zsh.sourceforge.net/ shells. Since lightning is written in "ruby":http://www.ruby-lang.org/, you'll need ruby 1.8.6 or later. To install lightning, use "rip":http://hellorip.com or "rubygems":http://rubygems.org:

<notextile><pre class='console'>
  $ rip install git://github.com/cldwalker/lightning.git
  # OR
  $ sudo gem install lightning
</pre></notextile>

If you've installed with rubygems and @`time lightning`@ takes longer than 0.05 seconds for you, I *strongly recommend* installing with rip. rubygems is known to have a hefty startup lag with older versions of ruby. Since lightning's autocompletion depends on this startup time, accepting this lag makes lightning slow as molasses.

Once lightning is installed, you'll need to do a one-time setup:

<notextile><pre class='console'>
  # To see available install options
  $ lightning install -h

  # Installs lightning's core files and sources the needed lightning functions
  $ lightning install && source ~/.lightning/functions.sh
  Created ~/.lightning_yml
  Created ~/.lightning/functions.sh

  # For all future examples I'll be using this alias
  $ alias lg=lightning

  # To have lightning's functionality loaded when your shell starts up
  echo source ~/.lightning/functions.sh >> ~/.bashrc
  # or for zsh
  echo source ~/.lightning/functions.sh >> ~/.zshrc
</pre></notextile>

h2(#intro). "Intro":#intro

Lightning provides shell functions which can interpret paths by their basenames. So instead of carpal-typing

<notextile><pre class='console'>
  $ less /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb
</pre></notextile>

just type

<notextile><pre class='console'>
  $ less-ruby irb.rb
</pre></notextile>

@less-ruby@ is a lightning function which wraps @less@ with the ability to refer to system ruby files by their basenames. Being a lightning function, it can also autocomplete system ruby files:

<notextile><pre class='console'>
  # 1112 available system ruby files
  $ less-ruby [TAB]
  Display all 1112 possibilities? (y or n)

  $ less-ruby a[TAB]
  abbrev.rb                  abstract.rb                abstract_index_builder.rb
  $ less-ruby abb[TAB]
  $ less-ruby abbrev.rb
  # Pages /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb ...

  # Autocompletion works regardless of the number of arguments
  $ less-ruby -I abbrev.rb y[TAB]
  yaml.rb      yamlnode.rb  ypath.rb
  $ less-ruby -I abbrev.rb yp[TAB]
  $ less-ruby -I abbrev.rb ypath.rb
  # Pages /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/abbrev.rb and
    /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/yaml/ypath.rb ...
</pre></notextile>

Note the '-I' which demonstrates @less-ruby@ can take any arguments that less normally takes. A lightning function __only translates__ the arguments it knows how to translate to full paths.

Also note @less-ruby@ referred to files from two different directories. @less-ruby@ 's 1112 files are actually spread across 118 directories. So what happens when two files from different directories are the same? Lightning let's you pick the right file in an autocomplete-friendly way:

<notextile><pre class='console'>
  $ less-ruby date[TAB]
  date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8
  date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/optparse
  date2.rb
  dateentry.rb
  datefield.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/tkextlib/iwidgets
  datefield.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/tkextlib/tcllib
  datetime.rb
  $ less-ruby date.rb[TAB]
  $ less-ruby date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8
  date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8
  date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/optparse
  $ less-ruby date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/[TAB]
  $ less-ruby date.rb///System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/optparse
  # Pages /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/optparse/date.rb ...
</pre></notextile>

The format for displaying conflicting basenames is @basename//directory@.

h2(#lightning_bolts). "Lightning Bolts":#lightning_bolts

To create @less-ruby@, a function that can autocomplete and access by basename 1112 files across 118 directories, must take a lot of effort. Right? Not really:

<notextile><pre class='console'>
  # These globs are specific to my filesystem
  # Arguments are quoted to prevent shell expansion
  $ lg bolt create ruby '/Library/Ruby/Site/1.8/**/*.{rb,bundle,so,c}'
    '/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/**/*.{rb,bundle,so,c}'
  Created bolt 'ruby'

  # Creates less-ruby and loads it into the shell
  $ lg function create less ruby && lightning-reload
  Created function 'less-ruby'
  Created /Users/bozo/.lightning/functions.sh
  Loaded /Users/bozo/.lightning/functions.sh
</pre></notextile>

The first command creates the ruby lightning bolt with two globs. This is *all the information* that a lightning function needs to know about the filesystem. The second command creates the lightning function by combining the bolt with the desired shell command, @less@ in this case. @lightning-reload@ creates and reloads lightning's functions into the current shell session.

Although these steps are fairly easy, you may have noticed that the globs were specific to my system. Fortunately, lightning let's you package up and generate globs with generators. Since lightning comes with a generator for the ruby bolt, you can get the above example working by replacing the first command with:

<notextile><pre class='console'>
  $ lg bolt generate ruby
  Generated following paths for bolt 'blah':
    /Library/Ruby/Site/1.8/**/*.{rb,bundle,so,c}
    /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/**/*.{rb,bundle,so,c}
</pre></notextile>

For more about generators, "read below":#generators.

Once you've created a bolt, you can use it to make multiple functions, each which wrap __any shell command you want__. For example, let's make a function that edits system ruby files:

<notextile><pre class='console'>
  $ lg function create vim ruby && lightning-reload
  Created function 'vim-ruby'
  Created /Users/bozo/.lightning/functions.sh
  Loaded /Users/bozo/.lightning/functions.sh

  $ vim-ruby abbrev.rb
  # Opens /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/abbrev.rb in vim
</pre></notextile>

In this section we've seen that a bolt abstracts a group of paths to a set of globs. Simply by remembering a bolt's name i.e. @ruby@, we can apply any command i.e. @vim-ruby@ or @less-ruby@ to the basenames of any of its paths. In essence, a bolt is a virtual, local directory whose __contents change__ depending on what its globs match. For more about bolts, "read here":#TODO.

h2(#everything_is_local). "Everything is Local":#everything_is_local

If a bolt is a virtual, _local_ directory, can we autocomplete and execute commands around any bolt path as if we were right there? Sure!

<notextile><pre class='console'>
  # echo-ruby calls `echo` with the ruby bolt
  $ echo-ruby abbrev.rb
  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/abbrev.rb

  # Autocomplete the directory containing abbrev.rb
  $ echo-ruby abbrev.rb/../[TAB]
  Display all 136 possibilities? (y or n)
  $ echo-ruby abbrev.rb/../md[TAB]
  $ echo-ruby abbrev.rb/../md5.rb
  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/md5.rb

  # Autocomplete multiple levels up or down
  $ echo-ruby abbrev.rb/../../[TAB]
  abbrev.rb/../../1.8/        abbrev.rb/../../gems/       abbrev.rb/../../site_ruby/  abbrev.rb/../../user-gems/
  $ echo-ruby abbrev.rb/../../../
  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib
  $ echo-ruby abbrev.rb/../irb/ext/s[TAB]
  $ echo-ruby abbrev.rb/../irb/ext/save-history.rb
  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb/ext/save-history.rb
</pre></notextile>

Bolt paths that are directories can also autocomplete and execute this way:

<notextile><pre class='console'>
  # less-gem calls `less` with the gem bolt (contains directories of rubygems)
  # less-gem ba[TAB]
  $ less-gem bacon-1.1.0
  $ less-gem bacon-1.1.0/l[TAB]
  $ less-gem bacon-1.1.0/lib/
  $ less-gem bacon-1.1.0/lib/b[TAB]
  $ less-gem bacon-1.1.0/lib/bacon.rb
  # Pages /Library/Ruby/Gems/1.8/gems/bacon-1.1.0/lib/bacon.rb ...
</pre></notextile>

If we can use filename expansion on local paths, why not bolt paths?

<notextile><pre class='console'>
  # grep-gem calls `grep` on the gem bolt
  # Let's search in different versions of a gem for the use of method_missing()
  $ grep-ruby -r def.*method_missing rai[TAB]
  rails-1.2.6  rails-2.1.0  rails-2.2.2  rails-2.3.4
  $ grep-ruby -r def.*method_missing rails-

  # Traditional filename expansion doesn't work
  $ grep-ruby -r def.*method_missing rails-*
  grep: rails-*: No such file or directory

  # Append '..' instead
  $ grep-ruby -r def.*method_missing rails-..
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/initializer.rb:  def method_missing(name, *args)
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/rails_generator/manifest.rb:      def method_missing(action, *args, &block)
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/rails_generator/simple_logger.rb:        def method_missing(method, *args, &block)
  /Library/Ruby/Gems/1.8/gems/rails-2.2.2/lib/initializer.rb:  def method_missing(name, *args)
  # ...

  # Why not use '*' for lightning as well?
  # Say you use a liberal expansion:
  #   $ grep-ruby -r def.*method_missing r*
  # If there happens to be a local file starting with 'r' i.e. 'readme',
  # the shell expands 'r*' to 'readme' and lightning will never see 'r*'.
</pre></notextile>

So lightning does filename expansion but only for arguments ending in @..@. When expanding matches, lightning treats everything before @..@ as a regular expression:

<notextile><pre class='console'>
  $ grep-gem -r def.*method_missing rubygems-u[TAB]
  rubygems-update-1.3.1  rubygems-update-1.3.2  rubygems-update-1.3.5  rubygems-update-1.3.6
  $ grep-gem -r def.*method_missing rubygems-update-1.3.
  # Only search two versions
  $ grep-gem -r def.*method_missing rubygems-update-1.3.[56]..
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.5/lib/rubygems/package.rb:  def method_missing(meth, *args, &block)
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.5/lib/rubygems/specification.rb:  def method_missing(sym, *a, &b) # :nodoc:
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.5/lib/rubygems/test_utilities.rb:  def method_missing(meth, *args, &block)
  # ...

  # To search either rubygems or rails
  $ grep-gem -r def.*method_missing '(rails|rubygems)..'
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/initializer.rb:  def method_missing(name, *args)
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/rails_generator/manifest.rb:      def method_missing(action, *args, &block)
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0/lib/rails_generator/simple_logger.rb:        def method_missing(method, *args, &block)
  /Library/Ruby/Gems/1.8/gems/rails-2.2.2/lib/initializer.rb:  def method_missing(name, *args)
  # ...

  # If you're unsure of what you're executing, test it with `lightning translate`
  # Prints arguments to be passed to grep, one per line
  $ lg translate grep-gem -r def.*method_missing '(rails|rubygems)..'
  -r
  def.*method_mis
  /Library/Ruby/Gems/1.8/gems/rails-2.1.0
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.1
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.2
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.5
  /Library/Ruby/Gems/1.8/gems/rubygems-update-1.3.6
  /Library/Ruby/Gems/1.8/gems/rails-2.2.2
  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/gems/1.8/gems/rails-1.2.6
  /Library/Ruby/Gems/1.8/gems/rubygems-sing-1.0.0
  /Library/Ruby/Gems/1.8/gems/rails-2.3.4
</pre></notextile>

h2(#generators). "Generators":#generators

"As was briefly shown":#lightning_bolts, generators generate bolts. The resulting bolts should have globs that work for any filesystem. To see what we can do with generators, let's look at lightning's default generators

<notextile><pre class='console'>
  $ lg generator
  bin
  gem
  gem_doc
  local_ruby
  ruby
  test_ruby
  wild
</pre></notextile>

We can use any of these generators to generate a bolt with the command @lightning bolt generate@

<notextile><pre class='console'>
  # Usage: lightning bolt generate BOLT [generator] [-t|-test]

  # Generates a bolt named ruby using the ruby generator
  $ lg bolt generate ruby
  Generated following paths for bolt 'ruby':
    /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/**/*.{rb,bundle,so,c}
    /Library/Ruby/Site/1.8/**/*.{rb,bundle,so,c}
  
  # Generates a bolt named ruby19 using the ruby generator
  $ lg bolt generate ruby19 ruby
  Generated following paths for bolt 'ruby19':
    /Users/bozo/.rvm/ruby-1.9.1-p378/lib/ruby/1.9.1/**/*.{rb,bundle,so,c}
    /Users/bozo/.rvm/ruby-1.9.1-p378/lib/ruby/site_ruby/1.9.1/**/*.{rb,bundle,so,c}

  # To test what a generator generates without making a bolt
  $ lg bolt generate ruby --test
  /Users/bozo/.rvm/ruby-1.9.1-p378/lib/ruby/1.9.1/**/*.{rb,bundle,so,c}
  /Users/bozo/.rvm/ruby-1.9.1-p378/lib/ruby/site_ruby/1.9.1/**/*.{rb,bundle,so,c}
</pre></notextile>

Once a bolt is created, "we've seen":#lightning_bolts how to create multiple lightning functions from it.

Since generators are important in distributing bolts that work for everyone, lightning let's users make their own generators. Simply drop your  own generators in a ruby file under @~/.lightning/generators/@.

So how do we make a generator? Let's look at the @bin@ generator:

<notextile><pre class='console'>
  module Lightning::Generators
    def bin
      ENV['PATH'].split(":").uniq.map {|e| "#{e}/*" }
    end
    # ...
  end
</pre></notextile>

As you can see, a generator is simply a ruby method in @Lightning::Generators@ that generates an array of globs. Note that the generator depends on the shell variable @$PATH@ to ensure generated globs that work for any filesystem. For more generator examples, see "lightning's generators":http://github.com/cldwalker/lightning/tree/master/lib/lightning/generators or "my own":http://github.com/cldwalker/dotfiles/tree/master/.lightning/generators.

h2(#conclusion). "Conclusion":#conclusion

Hopefully this post has shown that "lightning":http://github.com/cldwalker/lightning can revolutionize how you interact with your filesystem. By abstracting a group of paths to a bolt's name and its globs, __any group of paths is only a bolt's name away__ from being used as if they were in the current directory. Although the examples have been specific to ruby paths, lightning can generate functions for any group of paths. Lightning's generators provide a way for users to share their bolts and thus how they use their filesystem.

This post was mostly an introduction to lightning and what it can do. A future post will cover using it in more depth. For more about lightning, visit its "homepage":http://tagaholic.me/lightning/ and "docs":http://tagaholic.me/lightning/doc/.